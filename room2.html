<!-- room-interactive.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Room — Orbit + Raycaster + Material Editor</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: system-ui, -apple-system, "Segoe UI", Roboto; }
    #canvas-container { width: 100vw; height: 100vh; display:block; position:relative; }

    /* UI panel */
    #ui {
      position: absolute;
      right: 16px;
      top: 16px;
      width: 300px;
      background: rgba(16,16,22,0.85);
      color: #fff;
      padding: 12px;
      border-radius: 10px;
      z-index: 20;
      backdrop-filter: blur(6px);
    }
    #ui h3 { margin: 0 0 8px 0; font-size:16px; color:#ffebcd; }
    .row { margin:8px 0; display:flex; gap:8px; align-items:center; }
    .row label { font-size:13px; width:110px; }
    input[type="range"] { width: 100%; }
    input[type="color"] { height:32px; width:48px; padding:0; border:0; }
    button { background:#6e48aa; border:none; color:white; padding:8px 10px; border-radius:6px; cursor:pointer; }
    button.small { padding:6px 8px; font-size:13px; }

    /* small info badge */
    #info-badge {
      position:absolute; left:16px; top:16px; z-index:20;
      background: rgba(255,255,255,0.9); color:#222; padding:8px 12px; border-radius:8px; font-size:13px;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="info-badge">Hover: <span id="hover-name">—</span>  •  Click to edit</div>

  <div id="ui" style="display:none;">
    <h3 id="selected-title">Selected</h3>

    <div class="row">
      <label>Color</label>
      <input id="colorPicker" type="color" value="#ffffff">
    </div>

    <div class="row">
      <label>Opacity</label>
      <input id="opacity" type="range" min="0" max="1" step="0.01" value="1">
      <div id="opVal" style="width:34px;text-align:right">1</div>
    </div>

    <div class="row">
      <label>Wireframe</label>
      <input id="wireframe" type="checkbox">
    </div>

    <div id="phong-controls" style="display:none;">
      <div class="row">
        <label>Shininess</label>
        <input id="shininess" type="range" min="0" max="200" step="1" value="30">
        <div id="shinVal" style="width:34px;text-align:right">30</div>
      </div>
    </div>

    <div id="standard-controls" style="display:none;">
      <div class="row">
        <label>Metalness</label>
        <input id="metalness" type="range" min="0" max="1" step="0.01" value="0.5">
        <div id="metVal" style="width:34px;text-align:right">0.5</div>
      </div>
      <div class="row">
        <label>Roughness</label>
        <input id="roughness" type="range" min="0" max="1" step="0.01" value="0.5">
        <div id="roughVal" style="width:34px;text-align:right">0.5</div>
      </div>
    </div>

    <div style="height:8px"></div>

    <div class="row">
      <button id="focusBtn" class="small">Focus</button>
      <button id="closeBtn" class="small">Close</button>
      <button id="resetMat" class="small">Reset</button>
    </div>

    <hr style="border:none;border-top:1px solid rgba(255,255,255,0.08); margin:10px 0">

    <div style="font-size:13px; color:#ddd; margin-bottom:6px">Lighting</div>
    <div class="row">
      <label>Sun Intensity</label>
      <input id="sunRange" type="range" min="0" max="2" step="0.05" value="1.2">
      <div id="sunVal" style="width:34px;text-align:right">1.2</div>
    </div>
    <div class="row">
      <label>Lamp Intensity</label>
      <input id="lampRange" type="range" min="0" max="2" step="0.05" value="0.9">
      <div id="lampVal" style="width:34px;text-align:right">0.9</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://esm.sh/three@0.150.0";
    import { OrbitControls } from "https://esm.sh/three@0.150.0/examples/jsm/controls/OrbitControls.js";

    // ---------- BASIC SCENE ----------
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xbfd1e5);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1, 0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;

    // ---------- CONFIG (from original) ----------
    
    const roomWidth = 7, roomDepth = 7, roomHeight = 3;

    const loader = new THREE.TextureLoader();

    // Textures (place wall.jpg, floor.jpg, bed.jpg, blanket.jpg in same folder)
    const wallTexture = loader.load('wall.jpg');
    wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
    wallTexture.repeat.set(2,1);

    const floorTexture = loader.load('floor.jpg');
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(4,4);

    const bedTexture = loader.load('bed.jpg');
    bedTexture.wrapS = bedTexture.wrapT = THREE.RepeatWrapping;
    // blanket texture
    const blanketTexture = loader.load('blanket.jpg');
    blanketTexture.wrapS = blanketTexture.wrapT = THREE.RepeatWrapping;
    blanketTexture.repeat.set(2,2);

    // ---------- MATERIALS ----------
    const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, side: THREE.DoubleSide });
    const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture });
    const bedMaterial = new THREE.MeshStandardMaterial({ map: bedTexture, roughness: 0.7, metalness: 0.0 });
    const blanketMaterial = new THREE.MeshStandardMaterial({ map: blanketTexture, roughness: 0.2, metalness: 0.0 });
    const pillowMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });

    // ---------- FLOOR ----------
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, roomDepth), floorMaterial);
    floor.rotation.x = -Math.PI/2;
    floor.receiveShadow = true;
    scene.add(floor);

    // ---------- WALLS ----------
    // back, front, left
    const wallGeom = new THREE.PlaneGeometry(roomWidth, roomHeight);
    const wallBack = new THREE.Mesh(wallGeom, wallMaterial);
    wallBack.position.set(0, roomHeight/2, -roomDepth/2);
    scene.add(wallBack);

    const wallFront = new THREE.Mesh(wallGeom, wallMaterial);
    wallFront.position.set(0, roomHeight/2, roomDepth/2);
    wallFront.rotation.y = Math.PI;
    scene.add(wallFront);

    const wallLeft = new THREE.Mesh(wallGeom, wallMaterial);
    wallLeft.position.set(-roomWidth/2, roomHeight/2, 0);
    wallLeft.rotation.y = Math.PI/2;
    scene.add(wallLeft);

    // ---------- RIGHT WALL WITH WINDOW (shape + hole) ----------
    const wallShape = new THREE.Shape();
    wallShape.moveTo(-roomWidth/2, 0);
    wallShape.lineTo(roomWidth/2, 0);
    wallShape.lineTo(roomWidth/2, roomHeight);
    wallShape.lineTo(-roomWidth/2, roomHeight);
    wallShape.lineTo(-roomWidth/2, 0);

    // window size
    const windowW = 2.0, windowH = 1.5, windowCenterY = 1.5;
    const hx = windowW/2, hyLow = windowCenterY - windowH/2, hyHigh = windowCenterY + windowH/2;
    const windowHole = new THREE.Path();
    windowHole.moveTo(-hx, hyLow);
    windowHole.lineTo(hx, hyLow);
    windowHole.lineTo(hx, hyHigh);
    windowHole.lineTo(-hx, hyHigh);
    windowHole.lineTo(-hx, hyLow);
    wallShape.holes.push(windowHole);

    const wallGeometry = new THREE.ShapeGeometry(wallShape);
    wallGeometry.computeBoundingBox();
    // remap UVs so texture looks good on shape
    const max = wallGeometry.boundingBox.max, min = wallGeometry.boundingBox.min;
    const offset = new THREE.Vector2(0 - min.x, 0 - min.y);
    const range = new THREE.Vector2(max.x - min.x, max.y - min.y);
    const pos = wallGeometry.attributes.position;
    const uvs = [];
    for (let i=0; i<pos.count; i++){
      const x = pos.getX(i), y = pos.getY(i);
      uvs.push((x + offset.x) / range.x, (y + offset.y) / range.y);
    }
    wallGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
    const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
    wallRight.rotation.y = -Math.PI/2;
    wallRight.position.set(roomWidth/2, 0, 0);
    scene.add(wallRight);

    // ---------- CEILING ----------
    const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, roomDepth), wallMaterial);
    ceiling.position.set(0, roomHeight, 0);
    ceiling.rotation.x = Math.PI/2;
    ceiling.receiveShadow = true;
    scene.add(ceiling);

    // ---------- WINDOW GLASS + FRAME ----------
    const windowGlass = new THREE.Mesh(
      new THREE.PlaneGeometry(windowW, windowH),
      new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
    );
    windowGlass.position.set(roomWidth/2 - 0.01, windowCenterY, 0);
    windowGlass.rotation.y = -Math.PI/2;
    scene.add(windowGlass);

    const frameMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const frameOffset = roomWidth/2 + 0.02;
    const frameThickness = 0.05;
    const frameTop = new THREE.Mesh(new THREE.BoxGeometry(windowW + 0.05, 0.1, frameThickness), frameMat);
    frameTop.position.set(frameOffset, windowCenterY + windowH/2 + 0.05, 0);
    frameTop.rotation.y = -Math.PI/2;
    scene.add(frameTop);
    const frameBottom = frameTop.clone();
    frameBottom.position.set(frameOffset, windowCenterY - windowH/2 - 0.05, 0);
    scene.add(frameBottom);
    const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, windowH + 0.05, frameThickness), frameMat);
    frameLeft.position.set(frameOffset, windowCenterY, -windowW/2 - 0.025);
    frameLeft.rotation.y = -Math.PI/2;
    scene.add(frameLeft);
    const frameRight = frameLeft.clone();
    frameRight.position.set(frameOffset, windowCenterY, windowW/2 + 0.025);
    scene.add(frameRight);

    // ---------- FURNITURE: bed + blanket + pillows ----------
    const bedWidth = roomWidth * 0.6, bedDepth = roomDepth/2 - 0.2, bedHeight = 0.5;
    const leftX = -roomWidth/2;
    const bedCenterX = leftX + bedWidth/2;
    const bedCenterZ = roomDepth/2 - bedDepth/2 - 0.05;

    const bedGeom = new THREE.BoxGeometry(bedWidth, bedHeight, bedDepth);
    const bed = new THREE.Mesh(bedGeom, bedMaterial);
    bed.position.set(bedCenterX, bedHeight/2, bedCenterZ);
    bed.castShadow = true;
    bed.receiveShadow = true;
    scene.add(bed);

    const blanketGeom = new THREE.BoxGeometry(bedWidth - 0.05, 0.05, bedDepth - 0.05);
    const blanket = new THREE.Mesh(blanketGeom, blanketMaterial);
    blanket.position.set(bedCenterX, bedHeight + 0.025, bedCenterZ);
    blanket.castShadow = true;
    blanket.receiveShadow = true;
    scene.add(blanket);

    // pillows (scaled spheres)
    function makePillow(x,z, name) {
      const g = new THREE.SphereGeometry(0.32, 32, 32);
      const m = pillowMaterial.clone();
      const p = new THREE.Mesh(g, m);
      p.scale.set(1.5,0.45,1.85);
      p.position.set(x, bedHeight + 0.32*0.45, z);
      p.castShadow = true;
      p.receiveShadow = true;
      p.name = name;
      scene.add(p);
      return p;
    }
    const pillow1 = makePillow(leftX + 0.625, bedCenterZ + bedDepth/2 - 0.95, "Pillow L");
    const pillow2 = makePillow(leftX + 0.625, bedCenterZ + bedDepth/2 - 2.15, "Pillow R");




    // ---------- DESK & CHAIR ----------
    const deskWidth = 3, deskDepth = 1.35, deskHeight = 0.75;
    const deskX = -roomWidth/2 + deskWidth/2 + 0.1;
    const deskZ = bedCenterZ - 4.5;

    const deskTop = new THREE.Mesh(new THREE.BoxGeometry(deskWidth, 0.05, deskDepth),
      new THREE.MeshStandardMaterial({ color:0x8B4513, roughness:0.8 }));
    deskTop.position.set(deskX, deskHeight, deskZ);
    deskTop.castShadow = true; deskTop.receiveShadow = true;
    scene.add(deskTop);

    const legGeom = new THREE.BoxGeometry(0.05, deskHeight, 0.05);
    const legMat = new THREE.MeshStandardMaterial({ color:0x5a3825 });
    function makeLeg(offsetX, offsetZ) {
      const leg = new THREE.Mesh(legGeom, legMat);
      leg.position.set(deskTop.position.x + offsetX * (deskWidth/2 - 0.025), deskHeight/2, deskTop.position.z + offsetZ * (deskDepth/2 - 0.025));
      leg.castShadow = true; leg.receiveShadow = true;
      scene.add(leg);
    }
    makeLeg(1,1); makeLeg(1,-1); makeLeg(-1,1); makeLeg(-1,-1);

    // Kursi kecil di depan meja
    const chairSeat = new THREE.Mesh(
      new THREE.BoxGeometry(0.6, 0.05, 0.6),
      new THREE.MeshStandardMaterial({ color: 0x444444 })
    );
    chairSeat.position.set(deskX + 0.1, 0.45, deskZ + 0.35);
    chairSeat.castShadow = true;
    chairSeat.receiveShadow = true;
    scene.add(chairSeat);

    const chairLegGeom = new THREE.BoxGeometry(0.05, 0.45, 0.05);
    const chairLegMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

    function makeChairLeg(offsetX, offsetZ) {
      const leg = new THREE.Mesh(chairLegGeom, chairLegMat);
      leg.position.set(
        chairSeat.position.x + offsetX * 0.25,
        0.225,
        chairSeat.position.z + offsetZ * 0.25
      );
      leg.castShadow = true;
      leg.receiveShadow = true;
      scene.add(leg);
    }

    makeChairLeg(1, 1);
    makeChairLeg(1, -1);
    makeChairLeg(-1, 1);
    makeChairLeg(-1, -1);

    // ---------- LAMP ----------
    const lampLight = new THREE.PointLight(0xfff8e7, 0.9, 10);
    lampLight.position.set(0, 2.6, 0);
    lampLight.castShadow = true;
    scene.add(lampLight);
    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), new THREE.MeshStandardMaterial({ emissive:0xffffaa, emissiveIntensity:1, color:0xffffff }));
    bulb.position.copy(lampLight.position);
    scene.add(bulb);

    // ---------- SUNLIGHT ----------
    const sunlight = new THREE.DirectionalLight(0xffffff, 1.2);
    sunlight.position.set(roomWidth, 2.2, 0);
    sunlight.target.position.set(0,1,0);
    sunlight.castShadow = true;
    sunlight.shadow.mapSize.width = 2048;
    sunlight.shadow.mapSize.height = 2048;
    sunlight.shadow.camera.left = -5;
    sunlight.shadow.camera.right = 5;
    sunlight.shadow.camera.top = 5;
    sunlight.shadow.camera.bottom = -5;
    scene.add(sunlight);
    scene.add(sunlight.target);

    // ---------- SELECTABLES (for raycaster) ----------
    // Choose which objects are interactive
    const selectables = [bed, blanket, pillow1, pillow2, deskTop, chairSeat, bulb, windowGlass, wallRight];

    // Ensure each has a readable name (some objects already had)
    bed.name = bed.name || "Bed";
    blanket.name = blanket.name || "Blanket";
    deskTop.name = deskTop.name || "Desk";
    chairSeat.name = chairSeat.name || "Chair Seat";
    windowGlass.name = "Window Glass";
    wallRight.name = "Right Wall";

    // ---------- RAYCASTER & INTERACTION ----------
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    let hoverObj = null;
    let selected = null;

    // helpers to store original emissive so we can restore
    function saveOriginal(obj){
      if(!obj.userData._original) {
        obj.userData._original = {
          color: obj.material.color ? obj.material.color.clone() : null,
          emissive: obj.material.emissive ? obj.material.emissive.clone() : null,
          opacity: obj.material.opacity,
          wireframe: !!obj.material.wireframe
        };
      }
    }

    function setHover(obj){
      if(hoverObj === obj) return;
      // restore previous
      if(hoverObj && hoverObj.userData && hoverObj.userData._original){
        if(hoverObj.material.emissive) hoverObj.material.emissive.copy(hoverObj.userData._original.emissive);
      }
      hoverObj = obj;
      if(hoverObj){
        saveOriginal(hoverObj);
        if(hoverObj.material && hoverObj.material.emissive){
          hoverObj.material.emissive.setHex(0x333333);
        }
      }
      document.getElementById('hover-name').textContent = hoverObj ? (hoverObj.name || 'Unnamed') : '—';
    }

    function onPointerMove(e){
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const ints = raycaster.intersectObjects(selectables, true);
      if(ints.length > 0) {
        setHover(ints[0].object);
      } else setHover(null);
    }

    function onPointerDown(e){
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const ints = raycaster.intersectObjects(selectables, true);
      if(ints.length > 0){
        const obj = ints[0].object;
        selectObject(obj);
      } else {
        deselect();
      }
    }

    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);

    // ---------- UI BINDINGS ----------
    const ui = document.getElementById('ui');
    const selectedTitle = document.getElementById('selected-title');
    const colorPicker = document.getElementById('colorPicker');
    const opacityRange = document.getElementById('opacity');
    const opVal = document.getElementById('opVal');
    const wireframeChk = document.getElementById('wireframe');
    const phongControls = document.getElementById('phong-controls');
    const shininessRange = document.getElementById('shininess');
    const shinVal = document.getElementById('shinVal');
    const standardControls = document.getElementById('standard-controls');
    const metalRange = document.getElementById('metalness'), metalVal = document.getElementById('metVal');
    const roughRange = document.getElementById('roughness'), roughVal = document.getElementById('roughVal');
    const focusBtn = document.getElementById('focusBtn'), closeBtn = document.getElementById('closeBtn'), resetMatBtn = document.getElementById('resetMat');

    const sunRange = document.getElementById('sunRange'), sunVal = document.getElementById('sunVal');
    const lampRange = document.getElementById('lampRange'), lampVal = document.getElementById('lampVal');

    sunRange.addEventListener('input', (e)=> {
      sunlight.intensity = parseFloat(e.target.value);
      sunVal.textContent = e.target.value;
    });
    lampRange.addEventListener('input', (e)=> {
      lampLight.intensity = parseFloat(e.target.value);
      lampVal.textContent = e.target.value;
      bulb.material.emissiveIntensity = lampLight.intensity;
    });

    function selectObject(obj){
      selected = obj;
      saveOriginal(selected);
      // show UI
      ui.style.display = 'block';
      selectedTitle.textContent = selected.name || 'Selected Object';

      // populate UI values from material (support MeshStandardMaterial & MeshPhongMaterial)
      if(selected.material && selected.material.color) colorPicker.value = '#' + selected.material.color.getHexString();
      opacityRange.value = selected.material.opacity !== undefined ? selected.material.opacity : 1;
      opVal.textContent = opacityRange.value;
      wireframeChk.checked = !!selected.material.wireframe;

      // Phong
      if(selected.material instanceof THREE.MeshPhongMaterial){
        phongControls.style.display = 'block';
        standardControls.style.display = 'none';
        shininessRange.value = selected.material.shininess !== undefined ? selected.material.shininess : 30;
        shinVal.textContent = shininessRange.value;
      } else if(selected.material instanceof THREE.MeshStandardMaterial){
        phongControls.style.display = 'none';
        standardControls.style.display = 'block';
        metalRange.value = selected.material.metalness !== undefined ? selected.material.metalness : 0;
        roughRange.value = selected.material.roughness !== undefined ? selected.material.roughness : 1;
        metalVal.textContent = metalRange.value;
        roughVal.textContent = roughRange.value;
      } else {
        phongControls.style.display = standardControls.style.display = 'none';
      }
    }

    function deselect(){
      if(!selected) return;
      // restore original emissive color if any
      if(selected.userData && selected.userData._original && selected.material && selected.material.emissive) {
        selected.material.emissive.copy(selected.userData._original.emissive);
      }
      selected = null;
      ui.style.display = 'none';
    }

    closeBtn.addEventListener('click', ()=> deselect());

    // Focus camera on selected object
    focusBtn.addEventListener('click', ()=>{
      if(!selected) return;
      // compute a simple offset: move camera to selected position + vector
      const box = new THREE.Box3().setFromObject(selected);
      const center = new THREE.Vector3();
      box.getCenter(center);
      // position camera a bit away (along camera->center direction)
      const dir = new THREE.Vector3().subVectors(camera.position, center).normalize();
      const newPos = center.clone().add(dir.multiplyScalar(2.5 + box.getSize(new THREE.Vector3()).length()));
      // animate camera move (very simple lerp)
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const frames = 36;
      let t = 0;
      const anim = () => {
        t++;
        const alpha = t/frames;
        camera.position.lerpVectors(startPos, newPos, alpha);
        controls.target.lerpVectors(startTarget, center, alpha);
        controls.update();
        if(t < frames) requestAnimationFrame(anim);
      };
      anim();
    });

    // Reset material to original values
    resetMatBtn.addEventListener('click', ()=>{
      if(!selected || !selected.userData || !selected.userData._original) return;
      const orig = selected.userData._original;
      if(orig.color && selected.material.color) selected.material.color.copy(orig.color);
      if(orig.emissive && selected.material.emissive) selected.material.emissive.copy(orig.emissive);
      if(orig.opacity !== undefined) {
        selected.material.opacity = orig.opacity;
        selected.material.transparent = orig.opacity < 1;
      }
      selected.material.wireframe = orig.wireframe;
      // reset property UI
      selectObject(selected);
    });

    // UI -> material bindings:
    colorPicker.addEventListener('input', (e) => {
      if(selected && selected.material && selected.material.color) selected.material.color.set(e.target.value);
    });
    opacityRange.addEventListener('input', (e) => {
      opVal.textContent = e.target.value;
      if(selected && selected.material) {
        selected.material.opacity = parseFloat(e.target.value);
        selected.material.transparent = selected.material.opacity < 1;
      }
    });
    wireframeChk.addEventListener('change', (e) => {
      if(selected && selected.material) selected.material.wireframe = e.target.checked;
    });
    shininessRange.addEventListener('input', (e) => {
      shinVal.textContent = e.target.value;
      if(selected && selected.material instanceof THREE.MeshPhongMaterial) selected.material.shininess = parseFloat(e.target.value);
    });
    metalRange.addEventListener('input', (e) => {
      metalVal.textContent = e.target.value;
      if(selected && selected.material instanceof THREE.MeshStandardMaterial) selected.material.metalness = parseFloat(e.target.value);
    });
    roughRange.addEventListener('input', (e) => {
      roughVal.textContent = e.target.value;
      if(selected && selected.material instanceof THREE.MeshStandardMaterial) selected.material.roughness = parseFloat(e.target.value);
    });

    // ---------- ANIMATE ----------
    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ---------- EVENTS ----------
    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // remember to show selected in hover name
    // initial lighting UI values
    sunVal.textContent = sunRange.value;
    lampVal.textContent = lampRange.value;

    // ---------- Notes ----------
    // - Place 'wall.jpg', 'floor.jpg', 'bed.jpg', 'blanket.jpg' in same folder as this html.
    // - Use local webserver if browser blocks module local file loads (e.g., `npx http-server` or `python -m http.server`).
    // - You can extend selectables[] to add more interactive objects (e.g., frames, rug).
  </script>
</body>
</html>
