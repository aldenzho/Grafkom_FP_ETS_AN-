<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Room with Window + Textured Walls & Floor</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from "https://esm.sh/three@0.150.0";
    import { OrbitControls } from "https://esm.sh/three@0.150.0/examples/jsm/controls/OrbitControls.js";

    // --- Konfigurasi ruang (mudah diubah) ---
    const roomWidth = 7;   // jarak antara kiri dan kanan (-3.5 .. +3.5)
    const roomDepth = 7;   // jarak antara belakang dan depan (-3.5 .. +3.5)
    const roomHeight = 3;

    // Scene & kamera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xbfd1e5);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 3);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1, 0);
    controls.update();

    // Loader
    const loader = new THREE.TextureLoader();

    // Wall texture
    const wallTexture = loader.load("wall.jpg");
    wallTexture.wrapS = THREE.RepeatWrapping;
    wallTexture.wrapT = THREE.RepeatWrapping;
    wallTexture.repeat.set(2, 1);
    const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, side: THREE.DoubleSide });

    // Floor texture
    const floorTexture = loader.load("floor.jpg");
    floorTexture.wrapS = THREE.RepeatWrapping;
    floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(4, 4);
    const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture });

    // --- Lantai ---
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, roomDepth), floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // --- Dinding belakang / depan / kiri ---
    const wallGeom = new THREE.PlaneGeometry(roomWidth, roomHeight);

    const wallBack = new THREE.Mesh(wallGeom, wallMaterial);
    wallBack.position.set(0, roomHeight / 2, -roomDepth / 2);
    scene.add(wallBack);

    const wallFront = new THREE.Mesh(wallGeom, wallMaterial);
    wallFront.position.set(0, roomHeight / 2, roomDepth / 2);
    wallFront.rotation.y = Math.PI;
    scene.add(wallFront);

    const wallLeft = new THREE.Mesh(wallGeom, wallMaterial);
    wallLeft.position.set(-roomWidth / 2, roomHeight / 2, 0);
    wallLeft.rotation.y = Math.PI / 2;
    scene.add(wallLeft);

    // --- Right wall dengan lubang jendela (Shape + hole) ---
    const wallShape = new THREE.Shape();
    wallShape.moveTo(-roomWidth / 2, 0);
    wallShape.lineTo(roomWidth / 2, 0);
    wallShape.lineTo(roomWidth / 2, roomHeight);
    wallShape.lineTo(-roomWidth / 2, roomHeight);
    wallShape.lineTo(-roomWidth / 2, 0);

    // ukuran jendela (relatif terhadap ruangan)
    const windowWidth = 2.0;
    const windowHeight = 1.5;
    const windowCenterY = 1.5; // tinggi tengah jendela

    const hx = windowWidth / 2;
    const hyLow = windowCenterY - windowHeight / 2;
    const hyHigh = windowCenterY + windowHeight / 2;

    const windowHole = new THREE.Path();
    windowHole.moveTo(-hx, hyLow);
    windowHole.lineTo(hx, hyLow);
    windowHole.lineTo(hx, hyHigh);
    windowHole.lineTo(-hx, hyHigh);
    windowHole.lineTo(-hx, hyLow);
    wallShape.holes.push(windowHole);

    const wallGeometry = new THREE.ShapeGeometry(wallShape);
    // remap UV agar texture wall di mesh shape tampil wajar
    wallGeometry.computeBoundingBox();
    const max = wallGeometry.boundingBox.max;
    const min = wallGeometry.boundingBox.min;
    const offset = new THREE.Vector2(0 - min.x, 0 - min.y);
    const range = new THREE.Vector2(max.x - min.x, max.y - min.y);
    const pos = wallGeometry.attributes.position;
    const uvs = [];
    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i);
      const y = pos.getY(i);
      uvs.push((x + offset.x) / range.x, (y + offset.y) / range.y);
    }
    wallGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));

    const wallRight = new THREE.Mesh(wallGeometry, wallMaterial);
    wallRight.rotation.y = -Math.PI / 2;
    wallRight.position.set(roomWidth / 2, 0, 0);
    scene.add(wallRight);

    // --- Ceiling (pakai wall texture juga) ---
    const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, roomDepth), wallMaterial);
    ceiling.position.set(0, roomHeight, 0);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.receiveShadow = true;
    scene.add(ceiling);

    // --- Kaca + frame jendela (tetap di posisi lubang) ---
    const windowGlass = new THREE.Mesh(
      new THREE.PlaneGeometry(windowWidth, windowHeight),
      new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
    );
    // kaca ditempelkan di bagian dalam tembok (sedikit offset agar tidak z-fighting)
    windowGlass.position.set(roomWidth / 2 - 0.01, windowCenterY, 0);
    windowGlass.rotation.y = -Math.PI / 2;
    scene.add(windowGlass);

    const frameMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const frameOffset = roomWidth / 2 + 0.02; // sedikit keluar dinding
    const frameThickness = 0.05;
    const frameTop = new THREE.Mesh(new THREE.BoxGeometry(windowWidth + 0.05, 0.1, frameThickness), frameMat);
    frameTop.position.set(frameOffset, windowCenterY + windowHeight / 2 + 0.05, 0);
    frameTop.rotation.y = -Math.PI / 2;
    scene.add(frameTop);

    const frameBottom = frameTop.clone();
    frameBottom.position.set(frameOffset, windowCenterY - windowHeight / 2 - 0.05, 0);
    scene.add(frameBottom);

    const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, windowHeight + 0.05, frameThickness), frameMat);
    frameLeft.position.set(frameOffset, windowCenterY, -windowWidth / 2 - 0.025);
    frameLeft.rotation.y = -Math.PI / 2;
    scene.add(frameLeft);

    const frameRight = frameLeft.clone();
    frameRight.position.set(frameOffset, windowCenterY, windowWidth / 2 + 0.025);
    scene.add(frameRight);

    // bed
    const bedWidth = roomWidth * 0.6;    
    const bedDepth = roomDepth / 2 - 0.2;
    const bedHeight = 0.5;

    const leftX = -roomWidth / 2;
    const bedCenterX = leftX + bedWidth / 2;
    const bedCenterZ = roomDepth / 2 - bedDepth / 2 - 0.05;

    // load tekstur untuk bed
    const bedTexture = loader.load('bed.jpg');
    bedTexture.wrapS = THREE.RepeatWrapping;
    bedTexture.wrapT = THREE.RepeatWrapping;

    // atur seberapa sering motif diulang di atas kasur (ubah angka kalau terlalu besar/kecil)
    bedTexture.repeat.set(Math.max(1, bedWidth / 2), Math.max(1, bedDepth / 2));

    // material kasur pakai texture (ukuran kasur tidak diubah)
    const bedMaterial = new THREE.MeshStandardMaterial({
      map: bedTexture,
      roughness: 0.7,
      metalness: 0.0
    });

    const bedGeometry = new THREE.BoxGeometry(bedWidth, bedHeight, bedDepth);
    const bed = new THREE.Mesh(bedGeometry, bedMaterial);
    bed.position.set(bedCenterX, bedHeight / 2, bedCenterZ);
    bed.castShadow = true;
    bed.receiveShadow = true;
    scene.add(bed);


    
    // blanket
    const blanketGeometry = new THREE.BoxGeometry(bedWidth - 0.05, 0.05, bedDepth - 0.05);
    // load texture
    const blanketTexture = loader.load("blanket.jpg");
    blanketTexture.wrapS = THREE.RepeatWrapping;
    blanketTexture.wrapT = THREE.RepeatWrapping;
    blanketTexture.repeat.set(2, 2); // ulangi agar kerutan lebih alami

    const blanketMaterial = new THREE.MeshStandardMaterial({ 
      map: blanketTexture,   
      roughness: 0.2,
      metalness: 0.0
    });

    const blanket = new THREE.Mesh(blanketGeometry, blanketMaterial);
    blanket.position.set(
      bedCenterX,
      bedHeight + 0.025, 
      bedCenterZ
    );
    blanket.castShadow = true;
    blanket.receiveShadow = true;
    scene.add(blanket);


    // Bantal kiri
    const pillowRadius = 0.32;
    const pillowGeometry = new THREE.SphereGeometry(pillowRadius, 32, 32);
    const pillowMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.8,
      metalness: 0.0
    });

    const leftWallX = -roomWidth / 2;
    const headZ = bedCenterZ + bedDepth / 2.25;
    const pillowInsetFromHead = 0.5;
    const pillowInsetFromLeftWall = 0.625;
    const pillowY = bedHeight + (pillowRadius * 0.45);

    // Bantal kiri
    const pillow1 = new THREE.Mesh(pillowGeometry, pillowMaterial);

    // skala bantal 
    pillow1.scale.set(1.5, 0.45, 1.85);

    pillow1.position.set(
      leftWallX + pillowInsetFromLeftWall,
      pillowY,
      headZ - pillowInsetFromHead
    );

    pillow1.castShadow = true;
    pillow1.receiveShadow = true;
    scene.add(pillow1);

    // bantal kanan
    const pillowRadius2 = 0.32;
    const pillowGeometry2 = new THREE.SphereGeometry(pillowRadius2, 32, 32);
    const pillowMaterial2 = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.8,
      metalness: 0.0
    });

    const leftWallX2 = -roomWidth / 2;
    const headZ2 = bedCenterZ + bedDepth / 300;
    const pillowInsetFromHead2 = 0.5;
    const pillowInsetFromLeftWall2 = 0.625;
    const pillowY2 = bedHeight + (pillowRadius2 * 0.45);
    // Bantal kanan
    const pillow2 = new THREE.Mesh(pillowGeometry2, pillowMaterial2);
    pillow2.scale.set(1.5, 0.45, 1.85);

    pillow2.position.set(
      leftWallX2 + pillowInsetFromLeftWall2,
      pillowY2,
      headZ2 - pillowInsetFromHead2 - 0.15 // offset kanan
    );

    pillow2.castShadow = true;
    pillow2.receiveShadow = true;
    scene.add(pillow2);

    // --- Meja Belajar 
    // Ukuran meja
    const deskWidth = 3;
    const deskDepth = 1.35;
    const deskHeight = 0.75;

    // posisi meja di kiri kasur
    const deskX = -roomWidth / 2 + deskWidth / 2 + 0.1; // sedikit masuk ke dalam dari dinding
    const deskZ = bedCenterZ - 4.5; 

    // Top table
    const deskTop = new THREE.Mesh(
      new THREE.BoxGeometry(deskWidth, 0.05, deskDepth),
      new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 })
    );
    deskTop.position.set(deskX, deskHeight, deskZ);
    deskTop.castShadow = true;
    deskTop.receiveShadow = true;
    scene.add(deskTop);

    // Kaki meja
    const legGeom = new THREE.BoxGeometry(0.05, deskHeight, 0.05);
    const legMat = new THREE.MeshStandardMaterial({ color: 0x5a3825 });

    function makeLeg(offsetX, offsetZ) {
      const leg = new THREE.Mesh(legGeom, legMat);
      leg.position.set(
        deskTop.position.x + offsetX * (deskWidth / 2 - 0.025),
        deskHeight / 2,
        deskTop.position.z + offsetZ * (deskDepth / 2 - 0.025)
      );
      leg.castShadow = true;
      leg.receiveShadow = true;
      scene.add(leg);
    }

    // empat kaki meja
    makeLeg(1, 1);
    makeLeg(1, -1);
    makeLeg(-1, 1);
    makeLeg(-1, -1);

    // Kursi kecil di depan meja
    const chairSeat = new THREE.Mesh(
      new THREE.BoxGeometry(0.6, 0.05, 0.6),
      new THREE.MeshStandardMaterial({ color: 0x444444 })
    );
    chairSeat.position.set(deskX + 0.1, 0.45, deskZ + 0.35);
    chairSeat.castShadow = true;
    chairSeat.receiveShadow = true;
    scene.add(chairSeat);

    const chairLegGeom = new THREE.BoxGeometry(0.05, 0.45, 0.05);
    const chairLegMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

    function makeChairLeg(offsetX, offsetZ) {
      const leg = new THREE.Mesh(chairLegGeom, chairLegMat);
      leg.position.set(
        chairSeat.position.x + offsetX * 0.25,
        0.225,
        chairSeat.position.z + offsetZ * 0.25
      );
      leg.castShadow = true;
      leg.receiveShadow = true;
      scene.add(leg);
    }

    makeChairLeg(1, 1);
    makeChairLeg(1, -1);
    makeChairLeg(-1, 1);
    makeChairLeg(-1, -1);

    // --- Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.25);
    scene.add(ambientLight);

    // Sunlight (dari jendela)
    const sunlight = new THREE.DirectionalLight(0xffffff, 1.2);
    sunlight.position.set(roomWidth, 2.2, 0); // di luar jendela
    sunlight.target.position.set(0, 1, 0);
    sunlight.castShadow = true;
    sunlight.shadow.mapSize.width = 2048;
    sunlight.shadow.mapSize.height = 2048;
    sunlight.shadow.camera.left = -5;
    sunlight.shadow.camera.right = 5;
    sunlight.shadow.camera.top = 5;
    sunlight.shadow.camera.bottom = -5;
    scene.add(sunlight);
    scene.add(sunlight.target);

    // Lampu dalam ruangan (point light)
    const lampLight = new THREE.PointLight(0xfff8e7, 0.9, 10);
    lampLight.position.set(0, 2.6, 0);
    lampLight.castShadow = true;
    scene.add(lampLight);

    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16),
      new THREE.MeshStandardMaterial({ emissive: 0xffffaa, emissiveIntensity: 1, color: 0xffffff }));
    bulb.position.copy(lampLight.position);
    scene.add(bulb);

    // --- Render loop ---
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
